# 0. 资源

可以看看langchain出品的RAG系列，地址在：https://github.com/langchain-ai/rag-from-scratch

HyDE对应的文档和论文可以查看:
- https://github.com/langchain-ai/langchain/blob/master/cookbook/hypothetical_document_embeddings.ipynb
- 论文：https://arxiv.org/abs/2212.10496

路由优化：
- Logical and Semantic routing，基于逻辑规则和语义的路由分发：https://python.langchain.com/docs/use_cases/query_analysis/techniques/routing#routing-to-multiple-indexes
- 也可以基于语义来实现分发Semantic routing，https://python.langchain.com/docs/expression_language/cookbook/embedding_router

# 1. 简介

RAG优化是一个全面的过程，它包括数据预处理、优化检索、索引设计等多个方面。这些内容的整合，才能让RAG模型发挥出真正的潜力。

LangChain 团队最近的一场演讲，提供了一系列的优化方法，总共6个部分，主要受限于篇幅问题，今天先聊聊第一部分查询重写。

![](.03_查询重写方法汇总_images/优化概览.png)

首先为什么需要查询重写？我觉得主要是两个方面，第一个是很多时候用户的提问是不可控的，如果问题比较模糊，就很容易得不到想要的答案。

第二个方面检索的内容，如果本身资料包含的内容表达也不是很清晰的，比如企业内部的培训文档。那也容易导致匹配失败，最终会让大模型生成的答案不清晰。

为了尽量缓解这些问题，RAG检索的第一步，就是需要对问题进行一定的处理。

LangChain团队给出了5种方法，Step Back、HyDE、多重查询、查询融合、查询分解。

# 2. 方法详解

## 2.1 多重查询

多重查询的概念比较容易理解，就是担心一个问题回答的不准确，使用大模型把一个问题变成一堆问题，再进行多次检索。

这种技术就是尝试从多个角度补充原来的问题，变成多个问题尽量全面的从向量数据库中查找结果。目标是细化查询，使其与主题更加相关，从而从数据库中检索更多相关的文档。

LangChain和LlamaIndex都提供了多重查询的方法，直接调用就可以。

![](.03_查询重写方法汇总_images/多重查询.png)

## 2.2 RAG融合（RAG-Fusion）

RAG融合跟刚才的多重查询类似，不过在多重查询的基础上，在从向量数据库查询到的结果后，把查询结果再进行一次评分，把出现最多的资料排在上面，优先发给大模型。

利用倒数排序融合（RRF）和自定义向量评分加权，生成全面准确的结果。

RAG-Fusion希望弥合用户明确提出的问题和他们（原本的意图）打算提出的问题之间的差距，更接近于发现通常仍然隐藏的知识。

## 2.3 查询分解

查询分解是通过将问题分解为子问题来改善问答效果的策略，分两条实现路径：

（1）序列求解，将上一个子问题的答案与当前问题一并扔给LLM生成答案，再把当前生成答案与下一个子问题一起给LLM生成答案，直到最后一个子问题生成最终答案；

（2）并行的独立回答问题，然后将多路答案合并为最终答案。

## 2.4 Step Back

翻译是退后一步？Step-back prompting（又是一篇来自谷歌的paper，正着玩、反着玩，不给别人留点活路~）。

把问题变得更抽象。为什么要让问题变得更抽象？抽象的目的不是为了让你更迷糊，而是对问题进行了总结，提供了更大范围的检索。

## 2.5 HyDE

HyDE（Hypothetical Document Embeddings），这个最难理解，翻译是假设的含义。

这是先用大模型对问题生成一个假设答案，这个技术是认为假设的答案和文档中检索的答案可能更接近。

HyDE方法适合原始问题一般都比较短的情况，而生成的假设文档可能会更好地与索引文档对齐。

## 2.6 Routing路由优化策略

![](.03_查询重写方法汇总_images/路由1.png)

可用的方案包括，Logical and Semantic routing，基于逻辑规则和语义的路由分发：https://python.langchain.com/docs/use_cases/query_analysis/techniques/routing#routing-to-multiple-indexes

![](.03_查询重写方法汇总_images/路由2.png)

对应的具象化实现如下：

![](.03_查询重写方法汇总_images/路由示例.png)

可以通过function call来实现：

![](.03_查询重写方法汇总_images/function_call.png)

也可以基于语义来实现分发Semantic routing，https://python.langchain.com/docs/expression_language/cookbook/embedding_router

![](.03_查询重写方法汇总_images/语义分割.png)

![](.03_查询重写方法汇总_images/语义分割.png)

在实现上，可以为每个意图都设定一个prompt，然后进行判定，一个具象化的实现如下：

![](.03_查询重写方法汇总_images/语义prompt.png)

## 2.7 Query Construction问题构建优化策略

Query Construction，主要解决的问题是不同检索知识库，如mysql数据库、图数据库GraphDB、向量化数据库vectorDB的查询转换。使用LLM将自然语言转换为其中DSL是一种与给定数据库（SQL、Cypher等）交互所需的领域特定语言：https://blog.langchain.dev/query-construction/，https://blog.langchain.dev/enhancing-rag-based-applications-accuracy-by-constructing-and-leveraging-knowledge-graphs/

![](.03_查询重写方法汇总_images/query构建.png)

正在具体实现上，可以查看的方案，可以如下：

Query structuring for metadata filters，基于元数据过滤器的问题构建，例如，许多向量化存储都包含元数据字段，例如：

![](.03_查询重写方法汇总_images/query构建1.png)

这样就可以根据元数据过滤特定的数据chunk：https://python.langchain.com/docs/use_cases/query_analysis/techniques/structuring

![](.03_查询重写方法汇总_images/chunk过滤.png)



# 3. 总结

综合来看，问题重写的优化策略基本就是上下左右4个方向

- 把问题改写成多个
- 把问题总结
- 把问题分解
- 把问题通过大模型生成答案再检索

![](.03_查询重写方法汇总_images/流程.png)

不过这5种优化方式只是提供了一种思路，在OpenAI发布的一个成功案例中，里面提到了HyDE的优化方法，但实际效果并不好，所以没有采用。

但多重查询和RAG融合这两种技术，让我感觉这可以扩展成一个大模型集群。

# 参考

[1] 【深入浅出RAG】RAG提问重写优化：如何提高问题的准确性，https://mp.weixin.qq.com/s/ZrH296u44CX_Xipr4q0jZA
[2] 一文详看Langchain框架中的RAG多阶段优化策略：从问题转换到查询路由再到生成优化, https://mp.weixin.qq.com/s/pK2BRLrWpEKKIPFhUtGvcg